import * as vscode from "vscode";
import { exec } from "child_process";
import { promisify } from "util";
import { randomBytes } from "crypto";
import { rmSync } from "fs";
import { readdir, readFile } from "fs/promises";
import { resolve } from "path";
import { tmpdir } from "os";
import stripAnsi from "./stripAnsi";
import * as which from "which";

const execPromise = promisify(exec);
const randomBytesPromise = promisify(randomBytes);

// Types representing a Venom test suite

export interface TestSuite {
  name?: string;
  testcases: TestCase[];
}

export interface TestCase {
  name?: string;
}

// Types of the test_results.json file generated by Venom

// After v1.1.0-beta.5
interface TestResult {
  test_suites: TestResultTestSuite[];
}

interface TestResultTestSuite {
  name: string;
  testcases: TestResultTestCase[];
  nbTestcasesFail: number;
}

interface TestResultTestCase {
  name: string;
  status: "RUN" | "FAIL" | "SKIP" | "PASS";
  results: TestResultResult[];
}

interface TestResultResult {
  errors: TestResultFailure[];
}

// Before v1.1.0-beta.5
interface LegacyTestResult {
  test_suites: LegacyTestResultTestSuite[];
}

interface LegacyTestResultTestSuite {
  name: string;
  package: string;
  errors: number;
  failures: number;
  testcases: LegacyTestResultTestCase[];
}

interface LegacyTestResultTestCase {
  name: string;
  classname: string;
  errors: TestResultFailure[];
  failures: TestResultFailure[];
}

interface TestResultFailure {
  value: string;
}

// FIXME: this should use the official ExecException but it currently lacks stdout and stderr
// See: https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/58854
interface ExecException {
  code: number;
  stdout: string;
  stderr: string;
}

const findVenom = async () => {
  const venomBinary = vscode.workspace
    .getConfiguration("venom")
    .get<string>("binaryLocation", "venom");

  try {
    await which(venomBinary);
  } catch (e) {
    const choice = await vscode.window.showErrorMessage(
      "Venom binary not found. Install it in your PATH or configure its location manually.",
      "Install Venom",
      "Set Venom binary location"
    );

    switch (choice) {
      case "Install Venom":
        vscode.env.openExternal(
          vscode.Uri.parse("https://github.com/ovh/venom#installing")
        );
        break;
      case "Set Venom binary location":
        vscode.commands.executeCommand(
          "workbench.action.openSettings",
          "venom.binaryLocation"
        );
        break;
    }

    return null;
  }

  return venomBinary;
};

const checkVenomVersion = async () => {
  const versionResult = await version();
  if (!versionResult || versionResult.stdout.includes("v0")) {
    if (versionResult?.venomBinary) {
      const version = versionResult.stdout.split(": ")[1];
      vscode.window.showErrorMessage("Expected Venom binary version ≥ 1.0.0", {
        modal: true,
        detail: `${versionResult.venomBinary} has version ${version}`,
      });
    }
    return false;
  }
  return true;
};

export const version = async () => {
  const venomBinary = await findVenom();
  if (!venomBinary) {
    return null;
  }

  let stdout, stderr: string;
  try {
    ({ stdout, stderr } = await execPromise(`${venomBinary} version`));
  } catch (e) {
    ({ stdout, stderr } = e as ExecException);
  }

  return { stdout, stderr, venomBinary };
};

export const run = async (filepath: string, cwd: string) => {
  const venomBinary = await findVenom();
  if (!venomBinary) {
    return null;
  }

  if (!checkVenomVersion()) {
    return null;
  }

  const token = await randomBytesPromise(10);
  const venomTmpDir = resolve(tmpdir(), `venom-${token.toString("hex")}`);

  let command, stdout, stderr: string;
  try {
    const additionalArgs = vscode.workspace
      .getConfiguration("venom")
      .get<string[]>("additionalRunArguments", []);

    const args = [
      "--format=json",
      `--output-dir=${venomTmpDir}`,
      ...additionalArgs,
    ].join(" ");

    command = `IS_TTY=true ${venomBinary} run ${args} ${filepath}`;

    ({ stdout, stderr } = await execPromise(command, { cwd }));
  } catch (e) {
    ({ stdout, stderr } = e as ExecException);
  }

  let files = await readdir(venomTmpDir);
  files = files.filter((file) => file.endsWith(".json"));

  if (files.length !== 1) {
    let error: string;
    if (files.length === 0) {
      error = [
        "No JSON output file was generated.",
        "This might be an issue related to your Venom version.",
      ].join("\n");
    } else {
      error = [
        `${files.length} JSON output files were generated instead of a single one.`,
        "This might be an issue related to your Venom version.",
        ...files.map((file) => `- ${file}`),
      ].join("\n");
    }
    vscode.window.showErrorMessage("Unexpected Venom output", {
      modal: true,
      detail: error,
    });
    rmSync(venomTmpDir, { recursive: true, force: true });
    return {
      command,
      cwd: process.cwd(),
      stdout,
      stderr,
      errors: [error],
      failures: [],
    };
  }
  const filename = files[0];

  const rawTestResults = await readFile(resolve(venomTmpDir, filename));
  rmSync(venomTmpDir, { recursive: true, force: true });

  let errors: string[] = [];
  let failures: string[] = [];
  if (filename === "test_results.json") {
    // Venom < v1.1.0-beta.5, legacy format
    const testResults = JSON.parse(
      rawTestResults.toString()
    ) as LegacyTestResult;

    errors = testResults.test_suites
      .filter(
        (testSuite) =>
          filepath.endsWith(testSuite.package) && testSuite.errors > 0
      )
      .flatMap((failedTestSuite) => failedTestSuite.testcases)
      .filter((testCase) => testCase.errors !== null)
      .flatMap((testCase) => testCase.errors)
      .map((error) => error.value);

    failures = testResults.test_suites
      .filter(
        (testSuite) =>
          filepath.endsWith(testSuite.package) && testSuite.failures > 0
      )
      .flatMap((failedTestSuite) => failedTestSuite.testcases)
      .filter((testCase) => testCase.failures !== null)
      .flatMap((testCase) => testCase.failures)
      .map((failure) => failure.value);
  } else {
    // Venom ≥ v1.1.0-beta.5, new format
    const testResults = JSON.parse(rawTestResults.toString()) as TestResult;

    // This version dropped the difference between errors and failures

    failures = testResults.test_suites
      .filter((testSuite) => testSuite.nbTestcasesFail > 0)
      .flatMap((failedTestSuite) => failedTestSuite.testcases)
      .filter((testCase) => testCase.status === "FAIL")
      .flatMap((testCase) => testCase.results)
      .flatMap((result) => result.errors)
      .map((failure) => failure.value);
  }

  return {
    command,
    cwd: process.cwd(),
    stdout,
    stderr,
    errors,
    failures,
  };
};

export const parseFailureMessage = (message: string) => {
  message = stripAnsi(message).trim();

  const re1 =
    /expected:\s+(?<expected>.*?)\s+got:\s+(?<actual>.*?)\s+\(.*:(?<line>\d+)\)$/;
  const match1 = re1.exec(message);
  if (match1?.groups) {
    return {
      raw: message,
      expected: match1.groups.expected,
      actual: match1.groups.actual,
      line: parseInt(match1.groups.line),
    };
  }

  const re2 = /\s+\(.*:(?<line>\d+)\)$/;
  const match2 = re2.exec(message);
  if (match2?.groups) {
    return {
      raw: message,
      line: parseInt(match2.groups.line),
    };
  }

  return {
    raw: message,
  };
};
